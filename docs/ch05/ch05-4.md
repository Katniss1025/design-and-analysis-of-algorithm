# 习题5.1 

1. 两个十进制$n$位数的积最少能拥有多少位数？最多呢？

   **解答：**

   最小的十进制$n$位数可以表示为$10^{n-1}$，最大的$n$位数可以表示为$10^n-1$。

   因此，两个十进制$n$位数乘积最小和最大分别为$10^{2n-2}、(10^n-1)^2$。

   最少位数和做多位数分别为$2n-1、2n$。

   

2. 用课本中介绍的分治算法来计算$2101\times 1130$

   **解答：**

   $$\begin{align*}2101\times 1130&=(2100+1)\times(1100+30)\\&=(21\times11)\times10^4+(21\times30+1\times11)\times10^2+(1\times30)\\&=(2\times1\times10^2+(2\times1+1\times1)\times10+1\times1)\times10^4+((2\times3\times10^2+(2\times0+1\times3)\times10+1\times0)+11)\times10^2+30\\&=(200+30+1)\times10^4+((600+30+0)+11)\times10^2+30\\&=2310000+64100+30\\&=2374130\end{align*}$$

3. a. 请证明等式$a^{\log_bc}=c^{\log_ba}$，5.4节使用了这个等式。

   b. 作为$M(n)$的闭合公式来说，为什么$n^{\log_23}$要比$3^{\log_2n}$好？

   **解答：**

   **a. **由换底公式$\log_ac=\frac{\log_bc}{\log_ba}$，可得：

   $$a^{\log_bc}=a^{\log_ac\log_ba}=(a^{\log_ac})^{\log_cb}=c^{\log_ba}$$

   **b.** 因为$n^{\log_23}$方便和$n^2$进行比较。

   

4. a. 在大整数乘法算法的乘法次数$M(n)$中，为什么不把乘以$10^n$时所做的乘法包括进去？

   b. 为了简单起见，我们假设$n$是2的乘方，其实，建立$M(n)$的递推关系时，我们做了另一个微妙的假设，它并不总时成立的（然而，它并不会改变最后的答案）。你能指出这个假设吗？

   **解答**：

   **a. **因为$10^n$直接加0就好不用逐一相乘计算

   **b.** 另一个假设是“$n/2$为偶数”

   

5. 在用笔算计算两个$n$位数乘法时，需要做多少次一位数的加法？可以忽略进位导致的加法。

   **解答：**

   笔算两个$n$位数乘法，就是利用竖式进行计算，一个数从个位开始乘另外一个数的每一位数，然后将处于同一位置的数字进行加和。若忽略进位加法，则加法次数可表示为：

   $$\begin{align*}A(n)&=(1+2+...+n-1)+(1+2+...+n-2)\\&=\frac{n(n-1)}{2}+\frac{(n-1)(n-2)}{2}\\&=(n-1)^2\end{align*}$$

   

6. 验证Strassen算法在计算$2\times 2$矩阵的乘法时作用到的公式。

   **解答：**

   $$\begin{align*}m_1+m_4-m_5+m_7&=(a_{00}+a_{11})(b_{00}+b_{11})+a_{11}(b_{10}-b_{00})-(a_{00}+a_{01})b_{11}+(a_{01}-a_{11})(b_{10}+b_{11})\\&=a_{00}b_{00}+a_{01}b_{10}\end{align*}$$

   $$\begin{align*}m_3+m_5&=a_{00}(b_{01}-b_{11})+(a_{00}+a_{01})b_{11}\\&=a_{00}b_{01}+a_{01}b_{11}\end{align*}$$

   $$\begin{align*}m_2+m_4&=(a_{10}+a_{11})b_{00}+a_{11}(b_{10}-b_{00})\\&=a_{10}b_{00}+a_{11}b_{10}\end{align*}$$

   $$\begin{align*}m_1+m_3-m_2+m_6&=(a_{00}+a_{11})(b_{00}+b_{11})+a_{00}(b_{01}-b_{11})-(a_{10}+a_{11})b_{00}+(a_{10}-a_{00})(b_{00}+b_{01})\\&=a_{10}b_{10}+a_{11}b_{11}\end{align*}$$	

7. 应用Strassen算法计算$\begin{bmatrix}1&0&2&1\\4&1&1&0\\0&1&3&0\\5&0&2&1\end{bmatrix}\times \begin{bmatrix}0&1&0&1\\2&1&0&4\\2&0&1&1\\1&3&5&0\end{bmatrix}$，当$n=2$时停止递归，也就是说，用蛮力法计算$2\times 2$矩阵的积。

   **解答**：

   **思路**：将原来$4\times4$的矩阵划分为4个$2\times2$的矩阵，应用Strassen公式进行计算，而$2\times2$矩阵乘积计算用蛮力法进行求解。

   **python代码**

   ```python
   def StrassenBrute(A,B):
       n = len(A)
       n2 = int(n/2)
       if n > 2:
           A00 = A[0:n2,0:n2]
           A01 = A[0:n2,n2:]
           A10 = A[n2:,0:n2]
           A11 = A[n2:,n2:]
           B00 = B[0:n2,0:n2]
           B01 = B[0:n2,n2:]
           B10 = B[n2:,0:n2]
           B11 = B[n2:,n2:]
           m1 = StrassenBrute(A00 + A11 , B00 + B11)
           print('m1:',m1)
           m2 = StrassenBrute(A10 + A11 , B00)
           print('m2:',m2)
           m3 = StrassenBrute(A00 , B01 - B11)
           print('m3:',m3)
           m4 = StrassenBrute(A11 , B10 - B00)
           print('m4:',m4)
           m5 = StrassenBrute(A00 + A01 , B11)
           print('m5:',m5)
           m6 = StrassenBrute(A10 - A00 , B00 + B01)
           print('m6:',m6)
           m7 = StrassenBrute(A01 - A11 , B10 + B11)
           print('m7:',m7)
           C00 = m1 + m4 - m5 + m7
           C01 = m3 + m5
           C10 = m2 + m4
           C11 = m1 + m3 - m2 + m6
       elif n == 2:
           C00 = A[0,0] * B[0,0] + A[0,1] * B[1,0]
           C01 = A[0,0] * B[0,1] + A[0,1] * B[1,1]
           C10 = A[1,0] * B[0,0] + A[1,1] * B[1,0]
           C11 = A[1,0] * B[0,1] + A[1,1] * B[1,1]
       return  np.vstack((np.hstack((C00,C01)),np.hstack((C10,C11))))
           
   # test
   T1 = np.mat([[1,0,2,1],[4,1,1,0],[0,1,3,0],[5,0,2,1]])
   T2 = np.mat([[0,1,0,1],[2,1,0,4],[2,0,1,1],[1,3,5,0]])
   # 题目要求计算方法
   StrassenBrute(T1,T2)
   # numpy自带矩阵乘法运算
   np.dot(T1,T2)
   ```

   **计算结果**：

   $$\begin{bmatrix}5&4&7&3\\4&5&1&9\\8&1&3&7\\5&8&7&7\end{bmatrix}$$

   

8. 对Strassen算法用到的加法次数的递推公式进行求解，假设$n$是2的乘方。

   **解答**：

   当$n>1$时，$A(n)=7A(n/2)+18(n/2)^2$

   当$n=1$时，$A(1)=0$

   若$n=2^k$，则

   $$\begin{align*}A(2^k)&=7A(2^{k-1})+18\times2^{2k-2}\\&=7^kA(2^{k-k})+18\Sigma_{i=0}^{k-1}7^i2^{2k-2i-2}\\&=18\times2^{2k-2}\Sigma_{i=0}^{k-1}(\frac{7}{4})^i\\&=18\times4^{k-1}\frac{(7/4)^k-1}{(7/4)-1}\\&=6(7^k-4^k)\end{align*}$$

   因此，$A(n)=6(7^{\log_2n}-4^{\log_2n})=6(n^{\log_27}-n^2)$

9. V.Pan发明了一种矩阵乘法的分治法，它的理论根据是两个70阶的矩阵相乘需要143640次乘法运算。求该算法的渐近效率（可以忽略加法），并将它和Strassen算法进行比较。

   **解答**：

   Pan提出的算法乘法次数递推公式为：

   当$n>1$时，$M(n)=143640M(n/70)$

   当$n=1$时，$M(1)=1$

   根据主定理，$a=143640,b=70,d=0$，因此，$a>b^d$，$M(n)=\Theta(n^{\log _ba})=\Theta(n^{\log _{70}143640})\approx\Theta(n^{2.795})$

   而Strassen算法的乘法次数为$M(n)=\Theta(n^{\log _27})\approx\Theta(n^{2.807})$

   因此，Pan提出的算法乘法计算次数更少。

   

10. 实现Strassen算法时，当矩阵的规模变得小于转换点时，常常会切换到蛮力法。做一个实验，确定你的计算机上的这个转换点。

   **解答**：略。
