### 习题9.4

#### 1.a.对于下面的数据构造一套哈夫曼编码：

|   字符   |  A   |  B   |  C   |  D   |  -   |
| :------: | :--: | :--: | :--: | :--: | :--: |
| 出现概率 | 0.4  | 0.1  | 0.2  | 0.15 | 0.15 |

（1）

<img src=".\images\image-20221020112129298.png" alt="image-20221020112129298" style="zoom: 50%;" />

（2）

<img src=".\images\image-20221020112516857.png" alt="image-20221020112516857" style="zoom: 50%;" />

（3)

<img src=".\images\image-20221020112756323.png" alt="image-20221020112756323" style="zoom: 50%;" />

(4)

<img src=".\images\image-20221020113004046.png" alt="image-20221020113004046" style="zoom: 50%;" />

(5)

<img src=".\images\image-20221020113341983.png" alt="image-20221020113341983" style="zoom: 50%;" />

  根据构造的哈夫曼树，得到代码字如下：

|   字符   |  A   |  B   |  C   |  D   |  -   |
| :------: | :--: | :--: | :--: | :--: | :--: |
| 出现概率 | 0.4  | 0.1  | 0.2  | 0.15 | 0.15 |
|  代码字  |  0   | 100  | 111  | 101  | 110  |

#### b.用a中的编码对文本ABACABAD进行编码。

|  A   |  B   |  A   |  C   |  A   |  B   |  A   |  D   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   | 100  |  0   | 111  |  0   | 100  |  0   | 101  |

  因此，ABACABAD被编码为0100011101000101。

#### c.对于100010111001010用a中的编码进行解码。

| 100  |  0   | 101  | 110  |  0   | 101  |  0   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  B   |  A   |  D   |  -   |  A   |  D   |  A   |

  因此，100010111001010解码后是BAD_ADA。

#### 2.出于数据传输的目的，我们常常需要一套码长差异最小的编码(在具有相同平均长度的编码中)。针对以下数据构造哈夫曼编码。在权重相同的情况下，选择不同的子树会导致两套不同的编码。请计算这两套编码码长的平均值和方差。

|   字符   |  A   |  B   |  C   |  D   |  E   |
| :------: | :--: | :--: | :--: | :--: | :--: |
| 出现概率 | 0.1  | 0.1  | 0.2  | 0.2  | 0.4  |

（一）第一种构造方式

（1）

<img src=".\images\image-20221020155220244.png" alt="image-20221020155220244" style="zoom:50%;" />

（2）

<img src=".\images\image-20221020155423938.png" alt="image-20221020155423938" style="zoom: 50%;" />

(3)

<img src=".\images\image-20221020160206993.png" alt="image-20221020160206993" style="zoom:50%;" />

(4)

<img src=".\images\image-20221020160433179.png" alt="image-20221020160433179" style="zoom:50%;" />

(5)

<img src=".\images\image-20221020161043660.png" alt="image-20221020161043660" style="zoom:50%;" />

  根据构造的哈夫曼树，得到代码字和码长如下：

|   字符   |  A   |  B   |  C   |  D   |  E   |
| :------: | :--: | :--: | :--: | :--: | :--: |
| 出现概率 | 0.1  | 0.1  | 0.2  | 0.2  | 0.4  |
|  代码字  | 1100 | 1101 | 111  |  10  |  0   |
|   码长   |  4   |  4   |  3   |  2   |  1   |

  因此，编码码长的平均值$\overline{l}=4*0.1+4*0.1+3*0.2+2*0.2+1*0.4=2.2$

​                                方差$Var=(4-2.2)^2*0.1+(4-2.2)^2*0.1+(3-2.2)^2*0.2+(2-2.2)^2*0.2+(1-2.2)^2*0.4=1.36$

（二）第二种构造方式

（1）

<img src=".\images\image-20221020163802328.png" alt="image-20221020163802328" style="zoom:50%;" />

（2）

<img src=".\images\image-20221020163902079.png" alt="image-20221020163902079" style="zoom:50%;" />

（3）

<img src=".\images\image-20221020164201015.png" alt="image-20221020164201015" style="zoom:50%;" />

（4）

<img src=".\images\image-20221020164527947.png" alt="image-20221020164527947" style="zoom:50%;" />

（5）

<img src=".\images\image-20221020164819367.png" alt="image-20221020164819367" style="zoom:50%;" />

  根据构造的哈夫曼树，得到代码字和码长如下：

|   字符   |  A   |  B   |  C   |  D   |  E   |
| :------: | :--: | :--: | :--: | :--: | :--: |
| 出现概率 | 0.1  | 0.1  | 0.2  | 0.2  | 0.4  |
|  代码字  | 100  | 101  | 110  | 111  |  0   |
|   码长   |  3   |  3   |  3   |  3   |  1   |

  因此，编码码长的平均值$\overline{l}=3*0.1+3*0.1+3*0.2+3*0.2+1*0.4=2.2$

​                                方差$Var=(3-2.2)^2*0.1+(3-2.2)^2*0.1+(3-2.2)^2*0.2+(3-2.2)^2*0.2+(1-2.2)^2*0.4=0.96$

#### 3.请指出是否每一种哈夫曼编码都有下面的特性:

#### a.频率最低的两个字符具有相同的码长。

  正确。根据哈夫曼编码的步骤，首先将选择权重（即频率）最低的两个字符的树分别作为左右子树形成新树，这就意味着这两个字符位于最终构造出的哈夫曼树的同一层，具有相同的编码长度。

#### b.频率较高的字符的码长总是小于等于频率较低的字符的码长。

  正确。根据哈夫曼编码的步骤，将依次选择权重（即频率）较低的树作为子树形成新树，这就使得频率低的字符在最终构造出的哈夫曼树中位于更深层，使得频率较高的字符的编码长度总是小于等于频率较低的字符的编码长度。

#### 5.a.为哈夫曼树的构造算法写一段伪代码。

*Algorithm Huffman(W[0..n-1])*

*//构造哈夫曼树的算法*

*//输入：权重数组$W$*

*//输出：构造出的哈夫曼树$T$*

*Initialize(Q)   //初始化大小为$n$的优先级队列$Q$，并依据$W$赋值*

*While $Q$ has more than one element do*  

​	*$T_l \longleftarrow Q_{min}$   //$Q_{min}是具有最小权重的树$*

​	*delete($Q_{min}$)*

​	*$T_r \longleftarrow Q_{min}$*

​	*delete($Q_{min}$)*

​	*create($T，T_l，T_r$)   //以$T_l、T_r$为左右子树构建新树$T$，并将$T$的权重赋值为$T_l、T_r$的权重和*

​	*insert $T$ into $Q$*

*return $T$*