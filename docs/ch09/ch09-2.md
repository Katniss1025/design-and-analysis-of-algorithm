### 习题9.2

#### 1.应用Kruskal算法求下列图的最小生成树。

a.

![image-20221018104935468](.\images\image-20221018104935468.png)

  下一步被选中的边加粗表示 。

| 树中的边 |                 边的有序列表                  |
| :------: | :-------------------------------------------: |
|          | **bc(1)** de(2) bd(3) cd(4) ab(5) ad(6) ce(6) |
|  bc(1)   | bc(1) **de(2)** bd(3) cd(4) ab(5) ad(6) ce(6) |
|  de(2)   | bc(1) de(2) **bd(3)** cd(4) ab(5) ad(6) ce(6) |
|  bd(3)   | bc(1) de(2) bd(3) cd(4) **ab(5)** ad(6) ce(6) |
|  ab(5)   |                                               |

 据此得到的最小生成树如下图所示。

<img src=".\images\image-20221018111751533.png" alt="image-20221018111751533" style="zoom: 50%;" />

b.

![image-20221018105556123](.\images\image-20221018105556123.png)

  下一步被选中的边加粗表示 。

| 树中的边 |                         边的有序列表                         |
| :------: | :----------------------------------------------------------: |
|          | **de(1)** cd(2) ef(2) ab(3) be(3) gh(3) ij(3) ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  de(1)   | de(1) **cd(2)** ef(2) ab(3) be(3) gh(3) ij(3) ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  cd(2)   | de(1) cd(2) **ef(2)** ab(3) be(3) gh(3) ij(3) ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  ef(2)   | de(1) cd(2) ef(2) **ab(3)** be(3) gh(3) ij(3) ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  ab(3)   | de(1) cd(2) ef(2) ab(3) **be(3)** gh(3) ij(3) ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  be(3)   | de(1) cd(2) ef(2) ab(3) be(3) **gh(3)** ij(3) ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  gh(3)   | de(1) cd(2) ef(2) ab(3) be(3) gh(3) **ij(3)** ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  ij(3)   | de(1) cd(2) ef(2) ab(3) be(3) gh(3) ij(3) ad(4) **cg(4)** ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  cg(4)   | de(1) cd(2) ef(2) ab(3) be(3) gh(3) ij(3) ad(4) cg(4) **ei(4)** ac(5) dh(5) fj(5) il(5) bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  ei(4)   | de(1) cd(2) ef(2) ab(3) be(3) gh(3) ij(3) ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) **il(5)** bf(6) hi(6) gk(6) hk(7) kl(8) jl(9) |
|  il(5)   | de(1) cd(2) ef(2) ab(3) be(3) gh(3) ij(3) ad(4) cg(4) ei(4) ac(5) dh(5) fj(5) il(5) bf(6) hi(6) **gk(6)** hk(7) kl(8) jl(9) |
|  gk(6)   |                                                              |

 据此得到的最小生成树如下图所示。

<img src=".\images\image-20221017193133783.png" alt="image-20221017193133783" style="zoom:50%;" />

#### 2.判断正误:

#### a.如果e是加权连通图中权重最小的边，它至少是图的一棵最小生成树的边。

  正确。按照Kruskal算法步骤，首先将选取权重最小的边，并加入树中，那么一定至少有一种选法使得e是第一个被选择的边，一定可以加入树中，即e至少是图的一棵最小生成树的边。

#### b.如果e是加权连通图中权重最小的边，它必定是图的每一棵最小生成树的边。

  错误。存在这样的情况，权重最小且相同的边有多条，在构建树时，其他权重最小的边先被选择并加入树中，这样再检查e，发现加入e后会构成环，那么此时e就无法加入树中，即e不一定是每一棵最小生成树的边。

#### c.如果加权连通图中每条边的权重都是互不相同的，该图必定只有一棵最小生成树。

  正确。只有当图中存在权重相同的边时，按权值非递减顺序排序，才会存在不同的排序方式，使得选择边并加入树的顺序不同，而生成不同的树；而当图中每条边权互不相同时，排序方式是唯一确定的，那么也就不存在多种树的构建方式，即必定只有一棵最小生成树。

#### d.如果加权连通图中每条边的权重不是互不相同的，该图必定不止有一棵最小生成树。

  错误。每条边的权重不是互不相同的，即存在几条边有相同的权重值，这样虽然按权值非递减顺序排序，会存在不同的排序方式，但可能在不同的排序方式下，这几条权值相同的边都应当被加入树中，不会形成回路，或只有固定的几条（或没有）应被加入树中，即无论顺序如何，都只有固定的边被选择才不会形成环，即只能有一棵最小生成树。

#### 4.对于包含负权重边的图，Kruskal算法都能正确工作吗？

  对于包含负权重边的图，Kruskal算法能正确工作。Kruskal算法构建最小生成树时，依据的实际上是各个边权重的大小关系，而与具体数值无关。那么对于包含负权重边的图，可以同时给各边权重加上一个正数，使得权重都为正，这就转化为了普通的构建最小生成树的问题，能够通过Kruskal算法简单求解。因为边权重的大小关系与原来相同，则按权值非递减顺序排序方式与原来也相同，选择边并加入树的顺序也与原来相同，这样构建的最小生成树即为原问题的最小生成树，说明图是否包含负权重边对Kruskal算法没有影响。

#### 5.设计一个求加权连通图的最大生成树算法，这是一种包含最大可能权重的树。

  根据第4题可知，图是否包含负权重边对Kruskal算法没有影响。则可以令图中所有边的权重取相反数，这样求最大生成树的问题可以等价转化为求权值为相反数的图的最小生成树的问题，即可利用原始的Kruskal算法求解。

#### 6.按照不相交子集的抽象数据类型中的操作重写Kruskal算法的伪代码。

*Algorithm Kruskal(G)*

*//构造最小生成树的Kruskal算法*

*//输入：加权连通图G=<V,E>*

*//输出：$E_T$，组成G的最小生成树的边的集合*

*按照边的权重$w(e_{i_1})\leq···\leq w(e_{i_|E|})$的非递减顺序对集合E排序*

*for each vertex $v\in V$*

​	*make($v$)*

*$E_T\longleftarrow\varnothing$; $ecounter\longleftarrow0$   //初始化树中边的顶点集合以及集合的规模*

*$k\longleftarrow0$   //初始化已处理的边的数量*

*while $ecounter<|V|-1$ do*

​	*$k\longleftarrow k+1$*

​	*if find($u$)$\ne$ find($v$)   //$u,v$是边$e_{ik}$端点*

​		*$E_T\longleftarrow E_T\cup{e_{ik}}$*

​		*$ecounter\longleftarrow ecounter+1$*

​		*union($u,v$)*

*return $E_T$*

#### 11.斯坦纳树 4个村庄坐落在欧几里得平面上一个单位正方形的4个顶点上。要求用最短的公路网把它们连接起来，使得每对村庄之间都有一条连通的路径。求这样一个网络。

  求得的网络如下图所示，$a,b,c,d$代表 4个村庄。

![image-20221018171225241](.\images\image-20221018171225241.png)