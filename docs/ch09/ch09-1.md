### 习题9.1

#### 1.为找零问题写一个贪婪算法的伪代码，它以金额$n$和硬币的面额$d_1>d_2>···>d_m$作为输入。该算法的时间效率类型是怎样的？

*Algorithm Change(n,D[1..m])*
*//找零问题贪婪算法实现的伪代码*
*//输入：金额n（非负整数）和硬币面额D[1..m]（降序排列的数组）*
*//输出：找零方案S[1..m]（表示每种面额硬币的数量）或者无解标识"no solution"*
*for i$\longleftarrow$1 to m do*
	*S[i]$\longleftarrow$$\lfloor n/D[i] \rfloor$*

​	*n$\longleftarrow$n mod D[i]*

*if n==0*

​	*return C*

*else*

​	*return "no solution"*

该算法的时间复杂度为O(m)。

#### 3.作业调度 如果在单处埋器上，有$n$个运行时间分别为$t_1,t_2,···,t_n$的已知作业，请考虑它们的调度问题。这些作业可以按任意顺序执行，一次只能执行一个作业。要求是安排一个调度计划，使得所有的作业在系统中花费的时间最少(一个作业在系统中花费的时间是该作业用于等待的时间和用于运行的时间的总和)。为该问题设计一个贪婪算法。

  假设这些作业以任意顺序$i_1,i_2,···,i_n$执行，则所有作业在系统中花费的总时间为$T=t_{i_1}+(t_{i_1}+t_{i_2})+···+(t_{i_1}+t_{i_2}+··+t_{i_n})=n*t_{i_1}+(n-1)*t_{i_2}+···+t_{i_n}$

  为使$T$最小，则显然应使$t_{i_1}$最小，$t_{i_2}$第二小，···，$t_{i_n}$最大。因此，该问题的贪婪算法即为：按执行时间的非递减顺序对作业排序，并按此顺序依次执行。

#### 6.向下均分 有$n>1$个相同的缸，其中一个有$W$品脱的水，而别的缸为空。你被允许执行下列操作:取两个缸，然后把他们中的水在两个缸之间均分。目标是通过执行上述一系列操作，使得初始有水的缸中的水最小化。完成这个任务的最好方法是什么?

  最好方法是：使有水的初始缸分别与剩余空缸中的某一个进行水均分，直至不再有空缸为止。

  要使得初始有水的缸中的水最少，即要使得初始空缸中总水量最大。为此，每步操作中，要使得初始空缸分得更多的总水量，就要选取剩余空缸中的一个与初始有水的缸均分，而在初始空缸内部均分是无效的。这样，最终初始有水的缸中的水量为$W/2^{n-1}$品脱，而初始空缸中的水量均大于此，无法继续均分，达到了既定目标。

#### 7.谣言传播 有$n$个人，每个人都拥有不同的谣言。通过发电子信息，他们相互想共享所有的谣言。假定发送者会在信息中包含他已知的所有谣言，而且一条信息只有一个收信人。设计一个贪心算法，保证再给个人都能获得所有谣言的条件下，是发送的信息数最小。

  解决该问题的贪心算法为：为这$n$个人随机编号$1,2,···,n-1,n$，然后，先由$1$给$2$发送信息，再由$2$给$3$发送信息，···，再由$n-1$给$n$发送信息，这样$n$就获得了所有的谣言，再让$n$分别给$1,2,···,n-1$各发送一条信息即可。

  该算法是基于每次发送信息都使得当前的收信人能获更多的谣言，据此发送的信息总数为$2n-2$。$2n-2$即为最小发送信息总数，因为要使得所有人获得所有的谣言，那么首先要将所有谣言汇聚至$1$人处，在此过程中至少有$n-1$个人要发送信息，至少共发送$n-1$条。同理，之后要将汇聚好的谣言分发给所有人，那么至少有$n-1$个人要接收信息，在此过程中，至少共发送$n-1$条。综上，发送的信息总数最小即为$2*(n-1)=2n-2$条。

#### 9. a.对下面的图应用Prim算法。优先队列中包括所有不在树中的顶点。

<img src=".\images\image-20221017182933877.png" alt="image-20221017182933877" style="zoom:80%;" />

  假设随机选择顶点$a$作为初始顶点，下一步被选中的顶点加粗表示 。

| 树中的顶点 |            优先队列中的顶点            |
| :--------: | :------------------------------------: |
|   a(-,-)   | b(a,5) c(a,7) d(a,$\infty$) **e(a,2)** |
|   e(a,2)   |        **b(e,3)** c(e,4) d(e,5)        |
|   b(e,3)   |           **c(e,4)** d(e,5)            |
|   c(e,4)   |               **d(c,4)**               |
|   d(c,4)   |                                        |

  据此得到的最小生成树如下图所示。

<img src=".\images\image-20221017191252169.png" alt="image-20221017191252169" style="zoom:50%;" />

#### 9. b.对下面的图应用Prim算法。优先对列中只包括边缘顶点。

<img src=".\images\image-20221017191526675.png" alt="image-20221017191526675" style="zoom:67%;" />

  假设随机选择顶点$a$作为初始顶点，下一步被选中的顶点加粗表示 。

| 树中的顶点 |        优先队列中的顶点         |
| :--------: | :-----------------------------: |
|   a(-,-)   |    **b(a,3)** c(a,5) d(a,4)     |
|   b(a,3)   | c(a,5) d(a,4) **e(b,3)** f(b,6) |
|   e(b,3)   | c(a,5) **d(e,1)** f(e,2) i(e,4) |
|   d(e,1)   | **c(d,2)** f(e,2) i(e,4) h(d,5) |
|   c(d,2)   | **f(e,2)** i(e,4) h(d,5) g(c,4) |
|   f(e,2)   | **i(e,4)** h(d,5) g(c,4) j(f,5) |
|   i(e,4)   | h(d,5) g(c,4) **j(i,3)** l(i,5) |
|   j(i,3)   |    h(d,5) **g(c,4)** l(i,5)     |
|   g(c,4)   |    **h(g,3)** l(i,5) k(g,6)     |
|   h(g,3)   |        **l(i,5)** k(g,6)        |
|   l(i,5)   |           **k(g,6)**            |
|   k(g,6)   |                                 |

  据此得到的最小生成树如下图所示。

<img src=".\images\image-20221017193133783.png" alt="image-20221017193133783" style="zoom:50%;" />

