### 习题9.3

#### 1.请解释，为了解决下面的问题，Dijkstra 算法和所操作的图是否要做调整？要做怎样的调整？

#### a.对于加权有向图，求解单起点最短路径问题。

  在将相邻顶点添加到边缘顶点集合时，同时考虑边的方向，求初始顶点到其它顶点的距离时需先保证路径方向是贯通的。

#### b.求一个加权图或者有向图中两个顶点之间的最短路径[这个变化形式被称为单对最短路径问题]。

  将两个顶点中的一个设定为初始顶点，并应用Dijkstra 算法，直到另一个顶点被添加到树顶点集合，即找到了两顶点间的最短路径时停止。

#### c.求一个加权图或有向图中所有其他顶点到一个给定顶点之间的最短路径[这个变化形式被称为单终点最短路径问题]。

  对于无向图，问题可以直接等价转换为单起点最短路径问题，即求解给定顶点到图中其它所有顶点的最短路径，求得路径后将每一步反向，就得到了以给定顶点为终点的最短路径；对于有向图，处理思路与无向图类似，只是需要先将各个有向边方向反转，再将问题等价转换为单起点最短路径问题，按上述步骤执行。

#### d.如果对图中的每个顶点都赋予一个非负的数字，求解这种图的单起点最短路径问题(路径的长度定义为组成路径的顶点数字之和)。

  构建一个新图，将这种图转化为加权图的形式：将图中每个顶点分裂为两个顶点，并连接这两个顶点形成边，边的权重设定为原始顶点被赋予的非负数字；然后，按图原本的方式连接各分裂的顶点，其中两顶点中一顶点用来连接“入边”、一顶点用来连接“出边”，并将这些原始边的权重设定为0。这样就将问题转化为了加权图的单起点最短路径问题，应用Dijkstra 算法直接求解即可。

#### 2.解下面这个单起点最短路径问题的实例，以顶点a作为起点。

a.

<img src=".\images\image-20221019110841943.png" alt="image-20221019110841943" style="zoom:80%;" />

  将下一个最接近的顶点加粗表示。

| 树中的顶点 |                      余下的顶点                      |
| :--------: | :--------------------------------------------------: |
|   a(-,0)   | b(-,$\infty$) c(-,$\infty$) **d(a,7)** e(-,$\infty$) |
|   d(a,7)   |         **b(d,7+2)** c(d,7+5) e(-,$\infty$)          |
|   b(d,9)   |              **c(d,12)** e(-,$\infty$)               |
|  c(d,12)   |                    **e(c,12+6)**                     |
|  e(c,18)   |                                                      |

  最短路径和它们的长度如下：

  从a到d：a-d，长度为7

  从a到b：a-d-b，长度为9

  从a到c：a-d-c，长度为12

  从a到e：a-d-c-e，长度为18

  据此得到的最短路径如下图所示。

<img src=".\images\image-20221019141421698.png" alt="image-20221019141421698" style="zoom: 50%;" />

b.

<img src=".\images\image-20221019142506279.png" alt="image-20221019142506279" style="zoom:80%;" />

  将下一个最接近的顶点加粗表示。

| 树中的顶点 |             余下的顶点              |
| :--------: | :---------------------------------: |
|   a(-,0)   |      **b(a,3)** c(a,5) d(a,4)       |
|   b(a,3)   | c(a,5) **d(a,4)** e(b,3+3) f(b,3+6) |
|   d(a,4)   | **c(a,5)** e(d,4+1) f(a,9) h(d,4+5) |
|   c(a,5)   | **f(e,5+2)** h(d,9) g(c,9) i(e,5+4) |
|   f(e,7)   |  **h(d,9)** g(c,9) i(e,9) j(f,7+5)  |
|   h(d,9)   | **g(c,9)** i(e,9) j(f,12) k(g,9+6)  |
|   g(c,9)   |     **i(e,9)** j(f,12) k(g,9+6)     |
|   i(e,9)   |    **j(f,12)** k(g,15) l(i,9+5)     |
|  j(f,12)   |         k(g,15) **l(i,14)**         |
|  l(i,14)   |             **k(g,15)**             |
|  k(g,15)   |                                     |

  最短路径和它们的长度如下：

  从a到b：a-b，长度为3

  从a到d：a-d，长度为4

  从a到c：a-c，长度为5

  从a到e：a-d-e，长度为5

  从a到f：a-d-e-f，长度为7

  从a到h：a-d-h，长度为9

  从a到g：a-c-g，长度为9

  从a到i：a-d-e-i，长度为9

  从a到j：a-d-e-f-j，长度为12

  从a到l：a-d-e-i-l，长度为14

  从a到k：a-c-g-k，长度为15

  据此得到的最短路径如下图所示。

<img src=".\images\image-20221019144822873.png" alt="image-20221019144822873" style="zoom: 50%;" />

#### 3.给出一个反例，说明对于包含负权重的加权连通图，Dijkstra算法可能会无效。

<img src=".\images\image-20221019152416704.png" alt="image-20221019152416704" style="zoom:67%;" />

  反例如上图所示。以顶点a为起点，那么首先根据c(a,3) b(a,5)，会把顶点c加入树中，认为从a到c的最短路径为a-c，长度为3。但是显然，由a经b到c（a-b-c）的路径长度为5-3=2<3，说明对于包含负权重的加权连通图，Dijkstra算法可能会无效。

#### 4.有一个加权连通图G，在对它求解单起点最短路径问题的过程中构造了一棵树T。下列说法是对还是错?

#### a.T是G的生成树。

  正确。在构造树的过程中，每一步都从余下的顶点中选一个加入树中，则形成的一定是一棵树，且最终会包含图的所有顶点，即是图的生成树。

#### b.T是G的最小生成树。

  错误。最小生成树是指树中所有边的权重之和最小，即构建树时每次都选择权重最小的边加入，是直接比较给定的边的权重。而对于最短路径，是对于各顶点而言，选择到起点权重和最小的路径，比较的是边的权重和，而不能保证单独边的权重小，不一定是最小生成树。

#### 5.为Dijkstra算法的简化版本写一段伪代码，对于用权重矩阵表示的图，只求出从一个给定顶点到其他所有顶点的距离(也就是最短路径的长度，而不是最短路径本身)。

*Algorithm Dijkstra(W[0..n-1,0..n-1],s)*

*//输入：非负边权重矩阵W和给定起点s（0到n-1的整数）*

*//输出：记录了从给定顶点到其它所有顶点的最短路径长度的数组D*

*for $i\longleftarrow0$ to n-1 do*

​	*$D[i]\longleftarrow \infty$*

​	*$flag[i]\longleftarrow false$*

*$D[s]\longleftarrow 0$*

*for $i\longleftarrow0$ to n-1 do*

​	*$dmin\longleftarrow \infty$*

​	*for $j\longleftarrow0$ to n-1 do*

​		*if not $flag[j]$ and $D[j]<dmin$*

​			*$jmin\longleftarrow j$*

​			*$dmin\longleftarrow D[jmin]$*

​	*$flag[jmin]\longleftarrow true$*

​	*for $j\longleftarrow0$ to n-1 do*

​		*if not $flag[j]$ and $dmin+W[jmin,j]<\infty$*

​			*$D[j]\longleftarrow dmin+W[jmin,j]$*

*return D*